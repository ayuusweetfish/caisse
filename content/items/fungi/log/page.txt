{{title.zh=}}FUNgi 工作日志
{{title.en=}}FUNgi Work Journal

{{date=}}2023.07
{{usemath=}}true

{{contents.zh=}}
!<h1 前情提要 #Summary>

FUNgi 是由友人 Y 设计的互动装置，是一个形似蘑菇的毛线织物，里面填充棉花。针织部分包括一些导电纱线，在受到挤压或拉伸时会改变电特性，可以由单片机检测到，发出对应的声音。
[电路图]

之前是毕业设计课题，但由于时间缘故未能完善互动功能，只通过蜂鸣器发出声音，且并非所有互动区域都能出声。此次主要工作是协助完成技术实现部分，参加一周后的一场小展览。

!<h1 Day -8 #Day-Minus-8>
看到了整个装置，非常可爱，要是家里有一个肯定天天抱着。
确认技术原理后补齐了相关知识。
!<list
  <<li <~~='
    电容传感的原理是，为了测量两个引脚之间的电容，将其中一端（发送引脚）的电压拉高，再持续检测另一端（接收引脚）的电压是否变高；记录其中的时间差。
    !<note 注：具体而言，由于 RC 串联网络的阶跃响应是 <math U(t) = U_0 \left(1 - \exp\left(-\frac t {RC}\right)\right)>，所以接收引脚的反应时间约为 <math t \rvert_{U=0.6U_0} = -(\log 0.4) RC \propto RC>，因此所探测到的时间差与电容成正比。根据此式也估算出具体的电容值，只不过在大部分场景中只关心比例与变化量。>
  '> >>
  <li 扬声器不可以用蜂鸣器代替，后者的频率响应有限，主要为方波设计，声音信号容易失真。>
  <<li <~~='
    从 Arduino 单片机输出扬声器时由于引脚输出功率不足（5 V × 20 mA = 0.1 W），所以需要一个放大器。参考 <link https://docs.arduino.cc/tutorials/generic/simple-audio-player Arduino 网站上的教程>，使用一个倍率设置为 200 的 LM386 放大器芯片，连接若干电阻与电容形成放大电路。
    !<img LM386_Amp_Schematic.png <= 利用 LM386 芯片连接外部组件形成的音频放大器电路。//（来源：上述链接页面 / LM386 数据手册）> syncdark caption>
    左侧与地之间的 10 kΩ 可变电阻相当于将输入电压乘以一个倍率（可变电阻的英语 <lang en potentiometer> 其实就是“测量电势”的意思！）。此电阻与其串联的 10 µF 形成高通滤波器，过滤输入的直流偏置，截止频率 f_0 = 1/RC = 1/(10 kΩ × 10 µF) = 10 rad/s = 1.6 Hz。集成芯片 1 号与 8 号引脚之间的 10 µF 电容用于改变放大倍率（参考数据手册）。右侧元件的作用暂时没搞明白。
    !<note 注：实际上，右侧接地的串联 RC 是一个特定于此芯片的去耦网络，按照数据手册第 9 章的说明添加即可；末尾的电容与扬声器则串联成为 RC 网络，于是在扬声器两端形成高通滤波。数据手册给出的 250 µF 电容值适用于耳机、音响的较大阻抗，如果使用 8 Ω 的小喇叭，需要按照截止频率 1/(2πRC) = 20 Hz 重新计算电容，得到电容值约为 1000 µF。对这一点的忽视确实在后续造成了音质的问题，详见下文。>
  '> >>
>
购入所需元器件；由于所有电容两侧电压方向均固定，可任意选用有极性电容。0.05 µF 与 250 µF 都没有找到精确值的元件，分别用 47 nF（0.047 µF）与 220 µF 代替。电容元件的容差普遍较大，所以总归不太会有问题。

!<h1 Day -6 #Day-Minus-6>
拿到了友人工作室里的 Arduino 开发板，有 Uno 和 Leonardo 等不同种类。打印出电容传感器读数，看到用手触碰时读数会变大。
明天的任务是为所有引出的线贴好标签，并且确定触发检测算法及传感阈值。另外，需要试验多个区域同时按下时传感数值的模式。

!<h1 Day -5 #Day-Minus-5>
意识到需要确认不同开发板上的传感器数值是否一致。由于当前所用程序库的传感数值基于处理器指令周期，理论上基频相同的处理器所得的值应当一致，不同处理器所得的值应相差常数倍。需要确认这一点。

写了一个程序，读出传感器读数；发现噪声有些大，改成连续取 5 次原始采样值，再反复 5 次并取中位数，便稳定许多。用顶上九个凸起的区域测试，看上去数值稳定了许多，而且同时按下两个时的变化也非常明显。如果有一个被触发的传感器数值为 200 而其余传感器数值可忽略的话，采样 25 次的耗时就是 200 × 25 / 310 = 16 ms，即采样频率 60 Hz。虽然还有不少优化空间（比如滑动平均，还有之前说的一次性检查所有引脚），但或许够用。顺便，发现 Uno 板的 0 和 1 号引脚似乎不好用，传感一直超时，只好从 2 号引脚开始。
!<note 注：实际上是由于 0 号和 1 号引脚用于 USART 通信的缘故。>

之前调研声音合成的时候看到过一个程序库 <link https://sensorium.github.io/Mozzi/ Mozzi>，然而它要求至少以 64 Hz 刷新音频缓冲，但是我们的原理并不能保证实时性，单次传感采样的耗时上限很大（数秒）。因此可能需要放弃 Mozzi，改用自行调用时钟中断。另外，由于传感采样高度依赖 CPU 忙循环，因此即使单次采样也需要在期间关闭中断（虽然不知道为什么 CapacitiveSensor 库的实现没有关闭……可能会影响一些准确度？），如果读数为 1000，则持续约 1000 / 310 = 3 ms，这个值对于音频应用来说仍然相当大；有可能需要考虑改写传感逻辑，在等待期间允许中断，计时改为 <tt micros()> 或者开启一个没有 prescaler 的时钟。

准备写一个程序用来再电脑上可视化观察串口数据。然后发现 Arduino IDE 自带一个 <lang en Serial Plotter>，无敌好用，那还自己写啥呀。不过 <lang en Plotter> 工具只支持八个值，需要额外在文字窗口里观察一下第九个数值。

由于自己并不了解人体与装置接地的物理模型，需要依靠实验来确认。将装置从架子上搬到地面上重新测试，观察到传感器数值基本没有变化。因此可能变化模式受环境的影响并不大。

用标签贴纸捆好引脚并标注顺序，测试传感区域与引脚之间的对应。顶上拍按区有一个电极没有接触，怀疑是内部的线松动，一时无法拆开，只能放弃之。
!<img Numbering-1.jpg <= 两行两列的拼图，每张均为毛绒玩具上的传感区域，图像上标注有数字。//左上起：拍按区、斗状区、揉捏区、凸条区> caption>
至于引脚的固定方式，确实可以按照颜色编码顺序，但究极偷懒的办法还是直接用标签捆起来……
!<img Bound-Pins.jpg <= 用黏性标签捆在一起的杜邦线头，插入 Arduino 的排针座。> square>

有了相对稳定的读数，传感算法则是水到渠成：将一段时间内的最低值作为基准，观察读数是否连续大于基准值即可。具体逻辑：为每个传感电极维护一个基准电容值（即最低值），根据原始值动态更新；然后将原始读数值与之作差，即得到过滤的读数。简化的程序如下。

!<<code= cpp
// 更新基准值，与原始读数取小者
if (base > result) base = result;
// 原始读数与基准值作差，得到过滤读数
result -= base;
// 每隔一段时间尝试增加基准值，以适应环境变化的情形
// 如果环境没有变化，增加量会在下一次刷新时抹去
if (lastBaseIncrement + 1000 < millis()) {
  base++;
  lastBaseIncrement = millis();
}
>>

试验过程中发现偶然的低值可能导致读数值长期偏大。改成每次循环至多允许基准值减少 1，这样便能长期稳定地判定触发了。以下是今天的完整程序。

!<filetable
  <file SensorInspect_0512.ino 传感器数值输出>
>

!<h1 Day -4 #Day-Minus-4>
基准值在每次循环中的减少量上限改成了 5，这样反应更快一些。发现昨天遗漏了踢打区的电极顺序标注，补之。
!<img Numbering-2.jpg <= 九个圆形凸起传感区，图像上标注数字。>>

之前购置的元件都已到齐，在面包板上搭建扬声器放大电路。
!<img Speaker-Components.jpg <= 陶瓷电容、电解电容、直插式芯片、杜邦线、面包板等元件器材。>>

没有 10 Ω 电阻，暂时用拥有的最小电阻 220 Ω 代替；这样与 0.05 µF 结合的低通滤波器截止频率是 14 kHz，只是勉强足够。考虑之后去机器人社团问问。

向 A0 引脚写入 250 Hz 方波信号，测试可以出声，然而只是滋滋声。没有示波器，用万用表检测，意识到 A0 输出仍然是 PWM —— Arduino Uno 并没有板上 DAC，有 DAC 的是 Arduino Zero；所以只能控制逻辑电平的占空比，没法像 Zero 的 A0 引脚那样输出任意模拟值。之前玩过树莓派就以为最简单的小板子都是 Zero……总之，按照我们现有的设备，必须加上外置 DAC。

在机器人社团拿到了 8.2 Ω 电阻，但是没有 DAC。线上购买可能来不及送达，或许只能明天早上去附近的电子元器件商城找了。关于选型，考虑并行 8 位 DAC080x 或者串行 12 位 DAC8512 （SPI）/ MCP4x21（SPI）/ MCP4725（I2C）；如果采样率为 16 kHz，那么后者要求约 200 kHz 的 GPIO 频率，即不低于 2.5 µs 的反应时间。
迷茫，看了会 DAC8512 和 MCP48x1 的数据手册，供电和接地都有那么多讲究，要把尖刺都过滤掉。这么说难道之前的滋滋声也是因为输入端只加了高通没加低通？DAC080x 看上去好麻烦，不仅要单独的参考电压，而且 Arduino 那可怜的引脚数未必能腾出 8 路并行输出，可能不太考虑了。可能优先找 DAC8512 和 MCP4821 这样串行接口的吧。话说为什么 V_s 是电源电压，V_SS 就是接地电压啊，长得那么像，好吓人。

!<h1 Day -3 #Day-Minus-3>
早早醒来睡不着，研究一些知识。
时钟中断。处理器主频是 16 MHz，因此将 prescaler 设为 1024 可以获得 16 kHz 的中断频率。查阅 Uno 和 Leonardo 板上的控制器（分别是 ATmega328P 和ATmega32u4）数据手册，确认 Timer/Counter 的行为是兼容的。
采用 Timer/Counter1 溢出触发中断，撰写程序如下。每隔 16384 次中断翻转一次状态，间隔应为一秒。
!<<code= cpp
void setup() {
  // 清空 CS12:0，然后重新写入 0b101
  TCCR1B = (TCCR1B
    & ~((1 << CS12) | (1 << CS11) | (1 << CS10)))
    |  ((1 << CS12) | (0 << CS11) | (1 << CS10));
  TIMSK1 |= (1 << TOIE1);
  pinMode(13, OUTPUT);
}

ISR(TIMER1_OVF_vect) {
  static int timerCount = 0, pinStatus = 0;
  if ((timerCount = ((timerCount + 1) & 16383)) == 0)
    digitalWrite(13, (pinStatus ^= 1));
}

void loop() { }
>>
发现 CS12:0 = 0b101 时中断频率很低，约为 30 Hz，而 = 0b001 时大约是 31 kHz。所以 clk_I/O 是 31 kHz 吗？放弃挣扎直接向 ChatGPT 提问，它说溢出是每 65536 个时钟周期发生一次。顿悟了，果然自己还是笨乎乎的。明白原因之后就不那么担心了，直接这样达到 31 kHz 的采样率就很不错。
……但是仍然不对。如果是每 65536 个时钟周期一次的话，那么中断频率应该是 16 MHz / 65536 = 244 Hz 而不是 16 kHz。一顿翻找，在 ATmega32P 数据手册的 Table 15-5 看到 WGM12:0 也会影响计数器上限值，也即影响溢出发生的频率；有可能 Arduino 驱动程序为 WGM12:0 初始化的值不为 0（未查证）。将 WGM12:0 全部设为 0，频率确实下降到约 244 Hz。
!<<code= cpp
void setup() {
  TCCR1A = 0;   // WGM12:0 置零
  TCCR1B = (0 << CS12) | (0 << CS11) | (1 << CS10);
  TIMSK1 |= (1 << TOIE1);
  pinMode(13, OUTPUT);
}

ISR(TIMER1_OVF_vect) {
  static int timerCount = 0, pinStatus = 0;
  if ((timerCount = ((timerCount + 1) & 255)) == 0)
    digitalWrite(13, (pinStatus ^= 1));
}

void loop() { }
>>
因此设置 WGM12:0 = 0b001，采用 8 位 <lang en phase correct PWM> 模式（计数器到达 8 位上限 0xFF 后下降至 0，完成一次循环并触发溢出），即可获得 16 MHz / (256 × 2) = 31.25 kHz 的中断频率（事实上这似乎也是之前的默认值）。可以将其作为音频采样率的基础。
将 <tt setup()> 开头改为 <tt= TCCR1A = (1 << WGM10);> 即可。

放大器。重新研究了一下 LM386 数据手册，放大 200 倍的确实是电压，只不过在达到供电电压的时候会裁切。一看 6.1 节赫然写着最大输入 ±0.4 V，这么说昨天折腾那一通该不会把元件弄坏了吧……另外，真的很需要一根单独的电源。昨天那样直接从 Arduino 5V 引脚接出线来给放大器供电居然没有坏掉真是奇迹。但是为什么要把增益设成 200 呢，20 不是反而能充分利用 DAC 的精度吗，不理解。
以及，一个真正“开放”的平台应该很容易调试才对，像教程里这样引一个库然后“<lang en just works>”其实只是方便制作而不是理解。我至今不知道 <tt WavePlayer> 类的输出电压是多少。

等到大约上班的时候就出发去元器件商城，然而似乎周末不开门，遗憾离场。

下午回到学校，继续工作。复制了一份 CapacitiveSensor 库中的程序逻辑，将基于 CPU 周期的计时改为基于 <tt micros()>。原本自行实现的校正算法实现存在问题：由于使用 <tt int> 整型来存储 <tt lastBaseIncrement>“上次增加基准值的时刻”，而 ATmega 上的 <tt int> 是 16 位，因此 32768 毫秒之后基准值便不再每秒自增，于是基准值过低的问题再次出现。已修复。目前的采样率符合预期，闲置时约为 60 Hz，触发时约为 20~40 Hz。
增加滑动平均算法，每组采样 11 次、保留三组历史采样，这样一来在节省时间的同时将纳入考虑的采样次数增加到 33 次；同时改为取排序后中间三分之一数值的均值作为读数，稳定性进一步提升。
!<filetable
  <file Trigger_0514.ino 计时机制、滑动平均、触发判定>
>

剩余程序存储空间约 25 KiB，需要在其中实现音频合成算法。由于暂时无法继续电路方面的工作，计划先在电脑上编写合成器算法，最后再转移到 Arduino 上调试。
考虑一下是否可以将声音直接按采样存储下来。最近新出的 <link https://qoaformat.org/ QOA> 格式看上去很适合我们的场景，但它对 16 kHz 单声道仍然大约要求 50 kbps，如果使用采样，至多只能存储 4 s。还是需要更巧妙的合成算法啦，不排除要手写 Fourier 级数……

!<h1 Day -2 #Day-Minus-2>
搬到 Leonardo 板上试了一下，工作正常。改为 <tt micros()> 计时之后也不需要按照板的特性调整传感数值了，不过都是 16 MHz 的 AVR 的话好像也没什么区别。

完成第一块 MCP4821 分线板的焊接，开始编写程序。查阅手册，Figure 1-1 是时序图（注：16 MHz 主频相当于每条指令 62.5 ns，16 kHz 采样率相当于每个采样 62.5 µs），Section 5 是 SPI 接口说明。
有一个驱动库可以直接使用，很方便，不用自己啃数据手册了。将 DAC 的输出直接连到 A0 端口，读出数值。程序如下。
!<filetable
  <file DAC_0515.ino 驱动 DAC 并检查其输出端电压>
>
上述程序实际上就是切换高低输出电压，再通过 <tt analogRead(A0)> 读回。串口打印 <tt 0 0>、<tt 1 812>，其中 812 是 DAC 输出 4.095 V 与参考电压 5 V 的比值缩放到 0~1023 范围内的结果，在误差允许范围内正确。

开始将放大器 LM386 加入整个电路，焊接在洞洞板上。暂时还未继续处理声音合成的问题。
目前的电路原理图如下。Arduino 左侧留出的引脚仅作示意，可连接十个传感电极；实际上传感电极引出的杜邦线均直接插入板上的基座。
!<img Schematic-Day-Neg-2.png <= 电路原理图，Arduino 依次连接 MCP4821、LM386、扬声器，中间带有几组滤波电路。> syncdarkmild>

{{contents.en=}}

{{toc=}}true
