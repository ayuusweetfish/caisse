{{title.zh=}}FUNgi 工作日志
{{title.en=}}FUNgi Work Journal

{{date=}}2023.07

{{contents.zh=}}
!<h1 前情提要 #Summary>

FUNgi 是由友人 Y 设计的互动装置，是一个形似蘑菇的毛线织物，里面填充棉花。针织部分包括一些导电纱线，在受到挤压或拉伸时会改变电特性，可以由单片机检测到，发出对应的声音。
[电路图]

之前是毕业设计课题，但由于时间缘故未能完善互动功能，只通过蜂鸣器发出声音，且并非所有互动区域都能出声。此次主要工作是协助完成技术实现部分，参加一周后的一场小展览。

!<h1 Day -8 #Day-Minus-8>
看到了整个装置，非常可爱，要是家里有一个肯定天天抱着。
确认技术原理后补齐了相关知识。
!<list
  <li 电容传感的原理是，为了测量两个引脚之间的电容，将其中一端（发送引脚）的电压拉高、另一端（接收引脚）的电压拉低，再持续检测接收引脚的电压是否变高；记录其中的时间差。>
  <li 扬声器不可以用蜂鸣器代替，后者的频率响应有限，主要为方波设计，声音信号容易失真。>
  <<li <~~='
    从 Arduino 单片机输出扬声器时由于引脚输出功率不足（5 V × 20 mA = 0.1 W），所以需要一个放大器。参考 <link https://docs.arduino.cc/tutorials/generic/simple-audio-player Arduino 网站上的教程>，使用一个倍率设置为 200 的 LM386 放大器芯片，连接若干电阻与电容形成放大电路。
    !<img LM386_Amp_Schematic.png <= 利用 LM386 芯片连接外部组件形成的音频放大器电路。//（来源：上述链接页面 / LM386 数据手册）> syncdark caption>
    左侧与地之间的 10 kΩ 可变电阻相当于将输入电压乘以一个倍率（可变电阻的英语 <lang en potentiometer> 其实就是“测量电势”的意思！）。此电阻与其串联的 10 µF 形成高通滤波器，过滤输入的直流偏置，截止频率 f_0 = 1/RC = 1/(10 kΩ × 10 µF) = 10 rad/s = 1.6 Hz。集成芯片 1 号与 8 号引脚之间的 10 µF 电容用于改变放大倍率（参考数据手册）。右侧元件的作用暂时没搞明白。
    !<note 注：实际上，右侧接地的串联 RC 是一个特定于此芯片的去耦网络，按照数据手册第 9 章的说明添加即可；末尾的电容与扬声器则串联成为 RC 网络，于是在扬声器两端形成高通滤波。数据手册给出的 250 µF 电容值适用于耳机、音响的较大阻抗，如果使用 8 Ω 的小喇叭，需要按照截止频率 1/(2πRC) = 20 Hz 重新计算电容，得到电容值约为 1000 µF。对这一点的忽视确实在后续造成了音质的问题，详见下文。>
  '> >>
>
购入所需元器件；由于所有电容两侧电压方向均固定，可任意选用有极性电容。0.05 µF 与 250 µF 都没有找到精确值的元件，分别用 47 nF（0.047 µF）与 220 µF 代替。电容元件的容差普遍较大，所以总归不太会有问题。

!<h1 Day -6 #Day-Minus-6>
拿到了友人工作室里的 Arduino 开发板，有 Uno 和 Leonardo 等不同种类。打印出电容传感器读数，看到用手触碰时读数会变大。
明天的任务是为所有引出的线贴好标签，并且确定触发检测算法及传感阈值。另外，需要试验多个区域同时按下时传感数值的模式。

!<h1 Day -5 #Day-Minus-5>
意识到需要确认不同开发板上的传感器数值是否一致。由于当前所用程序库的传感数值基于处理器指令周期，理论上基频相同的处理器所得的值应当一致，不同处理器所得的值应相差常数倍。需要确认这一点。

写了一个程序，读出传感器读数；发现噪声有些大，改成连续取 5 次原始采样值，再反复 5 次并取中位数，便稳定许多。用顶上九个凸起的区域测试，看上去数值稳定了许多，而且同时按下两个时的变化也非常明显。如果有一个被触发的传感器数值为 200 而其余传感器数值可忽略的话，采样 25 次的耗时就是 200 × 25 / 310 = 16 ms，即采样频率 60 Hz。虽然还有不少优化空间（比如滑动平均，还有之前说的一次性检查所有引脚），但或许够用。顺便，发现 Uno 板的 0 和 1 号引脚似乎不好用，传感一直超时，只好从 2 号引脚开始。
!<note 注：实际上是由于 0 号和 1 号引脚用于 USART 通信的缘故。>

之前调研声音合成的时候看到过一个程序库 <link https://sensorium.github.io/Mozzi/ Mozzi>，然而它要求至少以 64 Hz 刷新音频缓冲，但是我们的原理并不能保证实时性，单次传感采样的耗时上限很大（数秒）。因此可能需要放弃 Mozzi，改用自行调用时钟中断。另外，由于传感采样高度依赖 CPU 忙循环，因此即使单次采样也需要在期间关闭中断（虽然不知道为什么 CapacitiveSensor 库的实现没有关闭……可能会影响一些准确度？），如果读数为 1000，则持续约 1000 / 310 = 3 ms，这个值对于音频应用来说仍然相当大；有可能需要考虑改写传感逻辑，在等待期间允许中断，计时改为 <tt micros()> 或者开启一个没有 prescaler 的时钟。

准备写一个程序用来再电脑上可视化观察串口数据。然后发现 Arduino IDE 自带一个 <lang en Serial Plotter>，无敌好用，那还自己写啥呀。不过 <lang en Plotter> 工具只支持八个值，需要额外在文字窗口里观察一下第九个数值。

由于自己并不了解人体与装置接地的物理模型，需要依靠实验来确认。将装置从架子上搬到地面上重新测试，观察到传感器数值基本没有变化。因此可能变化模式受环境的影响并不大。

用标签贴纸捆好引脚并标注顺序，测试传感区域与引脚之间的对应。
!<img Numbering-1.jpg <= 两行两列的拼图，每张均为毛绒玩具上的传感区域，图像上标注有数字。//左上起：拍按区、斗状区、揉捏区、凸条区> caption>
至于引脚的固定方式，确实可以按照颜色编码顺序，但究极偷懒的办法还是直接用标签捆起来……
!<img Bound-Pins.jpg <= 用黏性标签捆在一起的杜邦线头，插入 Arduino 的排针座。> square>

有了相对稳定的读数，传感算法则是水到渠成：将一段时间内的最低值作为基准，观察读数是否连续大于基准值即可。具体逻辑：为每个传感电极维护一个基准电容值（即最低值），根据原始值动态更新；然后将原始读数值与之作差，即得到过滤的读数。简化的程序如下。

!<<code= cpp
// 更新基准值，与原始读数取小者
if (base > result) base = result;
// 原始读数与基准值作差，得到过滤读数
result -= base;
// 每隔一段时间尝试增加基准值，以适应环境变化的情形
// 如果环境没有变化，增加量会在下一次刷新时抹去
if (lastBaseIncrement + 1000 < millis()) {
  base++;
  lastBaseIncrement = millis();
}
>>

试验过程中发现偶然的低值可能导致读数值长期偏大。改成每次循环至多允许基准值减少 1，这样便能长期稳定地判定触发了。以下是今天的完整程序。

!<filetable
  <file SensorInspect_0512.ino 传感器数值输出>
>

!<h1 Day -4 #Day-Minus-4>
基准值在每次循环中的减少量上限改成了 5，这样反应更快一些。发现昨天遗漏了踢打区的电极顺序标注，补之。
!<img Numbering-2.jpg <= 九个圆形凸起传感区，图像上标注数字。>>

之前购置的元件都已到齐，在面包板上搭建扬声器放大电路。
!<img Speaker-Components.jpg <= 陶瓷电容、电解电容、直插式芯片、杜邦线、面包板等元件器材。>>

没有 10 Ω 电阻，暂时用拥有的最小电阻 220 Ω 代替；这样与 0.05 µF 结合的低通滤波器截止频率是 14 kHz，只是勉强足够。考虑之后去机器人社团问问。

测试可以出声，然而只是滋滋声。没有示波器，用万用表检测，意识到 A0 输出仍然是 PWM —— Arduino Uno 并没有板上 DAC，有 DAC 的是 Arduino Zero；所以只能控制逻辑电平的占空比，没法像 Zero 的 A0 引脚那样输出任意模拟值。之前玩过树莓派就以为最简单的小板子都是 Zero……总之，按照我们现有的设备，必须加上外置 DAC。

在机器人社团拿到了 8.2 Ω 电阻，但是没有 DAC。线上购买可能来不及送达，或许只能明天早上去附近的电子元器件商城找了。关于选型，考虑并行 8 位 DAC080x 或者串行 12 位 DAC8512 （SPI）/ MCP4x21（SPI）/ MCP4725（I2C）；如果采样率为 16 kHz，那么后者要求约 200 kHz 的 GPIO 频率，即不低于 2.5 µs 的反应时间。
迷茫，看了会 DAC8512 和 MCP48x1 的数据手册，供电和接地都有那么多讲究，要把尖刺都过滤掉。这么说难道之前的滋滋声也是因为输入端只加了高通没加低通？DAC080x 看上去好麻烦，不仅要单独的参考电压，而且 Arduino 那可怜的引脚数未必能腾出 8 路并行输出，可能不太考虑了。可能优先找 DAC8512 和 MCP4821 这样串行接口的吧。话说为什么 V_s 是电源电压，V_SS 就是接地电压啊，长得那么像，好吓人。

{{contents.en=}}

{{toc=}}true
