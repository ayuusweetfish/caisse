{{title.zh=}}FUNgi 工作日志
{{title.en=}}FUNgi Work Journal

{{date=}}2023.07
{{usemath=}}true

{{contents.zh=}}
!<h1 前情提要 #Summary>

<link fungi FUNgi> 是由友人 Y 设计的互动装置，是一个形似树桩的毛线织物，里面填充棉花。针织部分包括一些导电纱线，在受到挤压或拉伸时会改变电特性，可以由单片机检测到，发出对应的声音。
!<img ../Circuit.png <= 示意图。电特性受触摸影响的导电纱线与普通纱线混织，与电阻串联，接在 Arduino 板上。> square syncdarkmild>

之前是毕业设计课题，但由于时间缘故未能完善互动功能，只通过蜂鸣器发出声音，且并非所有互动区域都能出声。此次主要工作是协助完成技术实现部分，参加一周后的一场小展览。

!<h1 Day -8 #Day-Minus-8>
看到了整个装置，非常可爱，要是家里有一个肯定天天抱着。
确认技术原理后补齐了相关知识。
!<list
  <<li <~~='
    电容传感的原理是，为了测量两个引脚之间的电容，将其中一端（发送引脚）的电压拉高，再持续检测另一端（接收引脚）的电压是否变高；记录其中的时间差。
    !<note 注：具体而言，由于 RC 串联网络的阶跃响应是 <math U(t) = U_0 \left(1 - \exp\left(-\frac t {RC}\right)\right)>，所以接收引脚的反应时间约为 <math t \rvert_{U=0.6U_0} = -(\log 0.4) RC \propto RC>，因此所探测到的时间差与电容成正比。根据此式也估算出具体的电容值，只不过在大部分场景中只关心比例与变化量。>
  '> >>
  <li 扬声器不可以用蜂鸣器代替，后者的频率响应有限，主要为方波设计，声音信号容易失真。>
  <<li <~~='
    从 Arduino 单片机输出扬声器时由于引脚输出功率不足（5 V × 20 mA = 0.1 W），所以需要一个放大器。参考 <link https://docs.arduino.cc/tutorials/generic/simple-audio-player Arduino 网站上的教程>，使用一个倍率设置为 200 的 LM386 放大器芯片，连接若干电阻与电容形成放大电路。
    !<img LM386_Amp_Schematic.png <= 利用 LM386 芯片连接外部组件形成的音频放大器电路。//（来源：上述链接页面 / LM386 数据手册）> syncdark caption>
    左侧与地之间的 10 kΩ 可变电阻相当于将输入电压乘以一个倍率（可变电阻的英语 <lang en potentiometer> 其实就是“测量电势”的意思！）。此电阻与其串联的 10 µF 形成高通滤波器，过滤输入的直流偏置，截止频率 f_0 = 1/RC = 1/(10 kΩ × 10 µF) = 10 rad/s = 1.6 Hz。集成芯片 1 号与 8 号引脚之间的 10 µF 电容用于改变放大倍率（参考数据手册）。右侧元件的作用暂时没搞明白。
    !<anchor Note-Filter-Value><note 注：实际上，右侧接地的串联 RC 是一个特定于此芯片的去耦网络，按照数据手册第 9 章的说明添加即可；末尾的电容与扬声器则串联成为 RC 网络，于是在扬声器两端形成高通滤波。数据手册给出的 250 µF 电容值适用于耳机、音响的较大阻抗，如果使用 8 Ω 的小喇叭，需要按照截止频率 1/(2πRC) = 20 Hz 重新计算电容，得到电容值约为 1000 µF。对这一点的忽视确实在后续造成了音质的问题，详见下文。>
  '> >>
>
购入所需元器件；由于所有电容两侧电压方向均固定，可任意选用有极性电容。0.05 µF 与 250 µF 都没有找到精确值的元件，分别用 47 nF（0.047 µF）与 220 µF 代替。电容元件的容差普遍较大，所以总归不太会有问题。

!<h1 Day -6 #Day-Minus-6>
拿到了友人工作室里的 Arduino 开发板，有 Uno 和 Leonardo 等不同种类。打印出电容传感器读数，看到用手触碰时读数会变大。
明天的任务是为所有引出的线贴好标签，并且确定触发检测算法及传感阈值。另外，需要试验多个区域同时按下时传感数值的模式。

!<h1 Day -5 #Day-Minus-5>
意识到需要确认不同开发板上的传感器数值是否一致。由于当前所用程序库的传感数值基于处理器指令周期，理论上基频相同的处理器所得的值应当一致，不同处理器所得的值应相差常数倍。需要确认这一点。

写了一个程序，读出传感器读数；发现噪声有些大，改成连续取 5 次原始采样值，再反复 5 次并取中位数，便稳定许多。用顶上九个凸起的区域测试，看上去数值稳定了许多，而且同时按下两个时的变化也非常明显。如果有一个被触发的传感器数值为 200 而其余传感器数值可忽略的话，采样 25 次的耗时就是 200 × 25 / 310 = 16 ms，即采样频率 60 Hz。虽然还有不少优化空间（比如滑动平均，还有之前说的一次性检查所有引脚），但或许够用。顺便，发现 Uno 板的 0 和 1 号引脚似乎不好用，传感一直超时，只好从 2 号引脚开始。
!<note 注：实际上是由于 0 号和 1 号引脚用于 USART 通信的缘故。>

之前调研声音合成的时候看到过一个程序库 <link https://sensorium.github.io/Mozzi/ Mozzi>，然而它要求至少以 64 Hz 刷新音频缓冲，但是我们的原理并不能保证实时性，单次传感采样的耗时上限很大（数秒）。因此可能需要放弃 Mozzi，改用自行调用时钟中断。另外，由于传感采样高度依赖 CPU 忙循环，因此即使单次采样也需要在期间关闭中断（虽然不知道为什么 CapacitiveSensor 库的实现没有关闭……可能会影响一些准确度？），如果读数为 1000，则持续约 1000 / 310 = 3 ms，这个值对于音频应用来说仍然相当大；有可能需要考虑改写传感逻辑，在等待期间允许中断，计时改为 <tt micros()> 或者开启一个没有 <lang en prescaler> 的时钟。

准备写一个程序用来在电脑上可视化观察串口数据。然后发现 Arduino IDE 自带一个 <lang en Serial Plotter>，无敌好用，那还自己写啥呀。不过 <lang en Plotter> 工具只支持八个值，需要额外在文字窗口里观察一下第九个数值。
!<img Plotter.jpg <= Serial Plotter 界面，彩色折线标示出不同电极的读数。折线显示出不同电极被触碰时的明显增量。>>

由于自己并不了解人体与装置接地的物理模型，需要依靠实验来确认。将装置从架子上搬到地面上重新测试，观察到传感器数值基本没有变化。因此可能变化模式受环境的影响并不大。

用标签贴纸捆好引脚并标注顺序，测试传感区域与引脚之间的对应。顶上拍按区有一个电极没有接触，怀疑是内部的线松动，一时无法拆开，只能放弃之。
!<img Numbering-1.jpg <= 两行两列的拼图，每张均为毛绒玩具上的传感区域，图像上标注有数字。//左上起：拍按区、斗状区、揉捏区、凸条区> caption>
至于引脚的固定方式，确实可以按照颜色编码顺序，但究极偷懒的办法还是直接用标签捆起来……
!<img Bound-Pins.jpg <= 用黏性标签捆在一起的杜邦线头，插入 Arduino 的排针座。> square>

有了相对稳定的读数，传感算法则是水到渠成：将一段时间内的最低值作为基准，观察读数是否连续大于基准值即可。具体逻辑：为每个传感电极维护一个基准电容值（即最低值），根据原始值动态更新；然后将原始读数值与之作差，即得到过滤的读数。简化的程序如下。

!<<code= cpp
// 更新基准值，与原始读数取小者
if (base > result) base = result;
// 原始读数与基准值作差，得到过滤读数
result -= base;
// 每隔一段时间尝试增加基准值，以适应环境变化的情形
// 如果环境没有变化，增加量会在下一次刷新时抹去
if (lastBaseIncrement + 1000 < millis()) {
  base++;
  lastBaseIncrement = millis();
}
>>

试验过程中发现偶然的低值可能导致读数值长期偏大。改成每次循环至多允许基准值减少 1，这样便能长期稳定地判定触发了。以下是今天的完整程序。

!<filetable
  <file SensorInspect_0512.ino 传感器数值输出>
>

!<h1 Day -4 #Day-Minus-4>
基准值在每次循环中的减少量上限改成了 5，这样反应更快一些。发现昨天遗漏了踢打区的电极顺序标注，补之。
!<img Numbering-2.jpg <= 九个圆形凸起传感区，图像上标注数字。>>

之前购置的元件都已到齐，在面包板上搭建扬声器放大电路。
!<img Speaker-Components.jpg <= 陶瓷电容、电解电容、直插式芯片、杜邦线、面包板等元件器材。>>

没有 10 Ω 电阻，暂时用拥有的最小电阻 220 Ω 代替；这样与 0.05 µF 结合的低通滤波器截止频率是 14 kHz，只是勉强足够。考虑之后去机器人社团问问。

向 A0 引脚写入 250 Hz 方波信号，测试可以出声，然而只是滋滋声。没有示波器，用万用表检测，意识到 A0 输出仍然是 PWM —— Arduino Uno 并没有板上 DAC，有 DAC 的是 Arduino Zero；所以只能控制逻辑电平的占空比，没法像 Zero 的 A0 引脚那样输出任意模拟值。之前玩过树莓派就以为最简单的小板子都是 Zero……总之，按照我们现有的设备，必须加上外置 DAC。

在机器人社团拿到了 8.2 Ω 电阻，但是没有 DAC。线上购买可能来不及送达，或许只能明天早上去附近的电子元器件商城找了。关于选型，考虑并行 8 位 DAC080x 或者串行 12 位 DAC8512 （SPI）/ MCP4x21（SPI）/ MCP4725（I2C）；如果采样率为 16 kHz，那么后者要求约 200 kHz 的 GPIO 频率，即不低于 2.5 µs 的反应时间。
迷茫，看了会 DAC8512 和 MCP48x1 的数据手册，供电和接地都有那么多讲究，要把尖刺都过滤掉。这么说难道之前的滋滋声也是因为输入端只加了高通没加低通？DAC080x 看上去好麻烦，不仅要单独的参考电压，而且 Arduino 那可怜的引脚数未必能腾出 8 路并行输出，可能不太考虑了。可能优先找 DAC8512 和 MCP4821 这样串行接口的吧。话说为什么 V_s 是电源电压，V_SS 就是接地电压啊，长得那么像，好吓人。

!<h1 Day -3 #Day-Minus-3>
早早醒来睡不着，研究一些知识。
时钟中断。处理器主频是 16 MHz，因此将 <lang en prescaler> 设为 1024 可以获得 16 kHz 的中断频率。查阅 Uno 和 Leonardo 板上的控制器（分别是 ATmega328P 和ATmega32u4）数据手册，确认 Timer/Counter 的行为是兼容的。
采用 Timer/Counter1 溢出触发中断，撰写程序如下。每隔 16384 次中断翻转一次状态，间隔应为一秒。
!<<code= cpp
void setup() {
  // 清空 CS12:0，然后重新写入 0b101
  TCCR1B = (TCCR1B
    & ~((1 << CS12) | (1 << CS11) | (1 << CS10)))
    |  ((1 << CS12) | (0 << CS11) | (1 << CS10));
  TIMSK1 |= (1 << TOIE1);
  pinMode(13, OUTPUT);
}

ISR(TIMER1_OVF_vect) {
  static int timerCount = 0, pinStatus = 0;
  if ((timerCount = ((timerCount + 1) & 16383)) == 0)
    digitalWrite(13, (pinStatus ^= 1));
}

void loop() { }
>>
发现 CS12:0 = 0b101 时中断频率很低，约为 30 Hz，而 = 0b001 时大约是 31 kHz。所以 clk_I/O 是 31 kHz 吗？放弃挣扎直接向 ChatGPT 提问，它说溢出是每 65536 个时钟周期发生一次。顿悟了，果然自己还是笨乎乎的。明白原因之后就不那么担心了，直接这样达到 31 kHz 的采样率就很不错。
……但是仍然不对。如果是每 65536 个时钟周期一次的话，那么中断频率应该是 16 MHz / 65536 = 244 Hz 而不是 16 kHz。一顿翻找，在 ATmega32P 数据手册的 Table 15-5 看到 WGM12:0 也会影响计数器上限值，也即影响溢出发生的频率；有可能 Arduino 驱动程序为 WGM12:0 初始化的值不为 0（未查证）。将 WGM12:0 全部设为 0，频率确实下降到约 244 Hz。例如，以下程序的闪烁周期略长于 1 秒。
!<<code= cpp
void setup() {
  TCCR1A = 0;   // WGM12:0 置零
  TCCR1B = (0 << CS12) | (0 << CS11) | (1 << CS10);
  TIMSK1 |= (1 << TOIE1);
  pinMode(13, OUTPUT);
}

ISR(TIMER1_OVF_vect) {
  static int timerCount = 0, pinStatus = 0;
  if ((timerCount = ((timerCount + 1) & 255)) == 0)
    digitalWrite(13, (pinStatus ^= 1));
}

void loop() { }
>>
因此设置 WGM12:0 = 0b001，采用 8 位 <lang en phase correct PWM> 模式（计数器到达 8 位上限 0xFF 后下降至 0，完成一次循环并触发溢出），即可获得 16 MHz / (256 × 2) = 31.25 kHz 的中断频率（事实上这似乎也是之前的默认值）。可以将其作为音频采样率的基础。
将 <tt setup()> 开头改为 <tt= TCCR1A = (1 << WGM10);> 即可。GPT 还是败了呢。

关于放大器。重新研究了一下 LM386 数据手册，放大 200 倍的确实是电压，只不过在达到供电电压的时候会裁切。一看 6.1 节赫然写着最大输入 ±0.4 V，这么说昨天折腾那一通该不会把元件弄坏了吧……另外，真的很需要一根单独的电源。昨天那样直接从 Arduino 5V 引脚接出线来给放大器供电居然没有坏掉真是奇迹。但是为什么要把增益设成 200 呢，20 不是反而能充分利用 DAC 的精度吗，不理解。
以及，一个真正“开放”的平台应该很容易调试才对，像教程里这样引一个库然后“<lang en just works>”其实只是方便制作而不是理解。我至今不知道 <tt WavePlayer> 类的输出电压是多少。

等到大约上班的时候就出发去元器件商城，然而似乎周末不开门，遗憾离场。

下午回到学校，继续工作。复制了一份 CapacitiveSensor 库中的程序逻辑，将基于 CPU 周期的计时改为基于 <tt micros()>。原本自行实现的校正算法实现存在问题：由于使用 <tt int> 整型来存储 <tt lastBaseIncrement>“上次增加基准值的时刻”，而 ATmega 上的 <tt int> 是 16 位，因此 32768 毫秒之后基准值便不再每秒自增，于是基准值过低的问题再次出现。已修复。目前的采样率符合预期，闲置时约为 60 Hz，触发时约为 20~40 Hz。
增加滑动平均算法，每组采样 11 次、保留三组历史采样，这样一来在节省时间的同时将纳入考虑的采样次数增加到 33 次；同时改为取排序后中间三分之一数值的均值作为读数，稳定性进一步提升。
!<filetable
  <file Trigger_0514.ino 计时机制、滑动平均、触发判定>
>

针对不同互动区调整阈值，也试着编写了不同的算法，效果还不错，虽然并不是最灵敏，不过也许已经接近目前传感方案的极限了。
!<filetable
  <file Trigger_Test_1.mp4 触发测试——踢打区>
  <file Trigger_Test_2.mp4 触发测试——揉捏区>
>

剩余程序存储空间约 25 KiB，需要在其中实现音频合成算法。由于暂时无法继续电路方面的工作，计划先在电脑上编写合成器算法，最后再转移到 Arduino 上调试。
考虑一下是否可以将声音直接按采样存储下来。最近新出的 <link https://qoaformat.org/ QOA> 格式看上去很适合我们的场景，但它对 16 kHz 单声道仍然大约要求 50 kbps，如果使用采样，至多只能存储 4 s。还是需要更巧妙的合成算法啦，不排除要手写 Fourier 级数……

!<h1 Day -2 #Day-Minus-2>
再次跑去市场。昨天去的地方有了人，但是他们推荐我去对面的商城，说那边多一些——所以昨天是跑错地方了啊！

询问是否有 5 V 驱动的串行 12-bit DAC，得知这里只支持自己选型然后按型号一个个问。感觉有点影响效率，但或许电子元器件市场就是这样子吧！

DAC8512 一片要 100 多……于是想着换成 MCP4821。业务员在电脑上敲了一会儿就开始打电话跟对面讲粤语问有没有 MCP4821（用粤语念英文字母好神奇！），一分钟后又打了个普通话的电话。最后的答复是整个市场上只有五块直插（读作：万一坏掉了就没救了x），而且单价要 55 元，比 Mouser 上的价格贵一倍，还需要等到饭点结束。被业务员推荐用贴片加转换板，贴片库存倒是很多，价格至少也和 Mouser 上的直插一样（27），算是可以接受了。我其实不太懂怎么用贴片（SOP-8），业务员十分热心地教我说只要焊上转换板就可以了，还给了我好多排针。买了 8 片，开销合计 (25 + 3) × 8 = 224。

今天外面真是超级热，最高气温有 35℃，不远处的汽车、栏杆、绿化，看上去都颤颤巍巍的。

下午把传感程序搬到 Leonardo 板上试了一下，工作正常。改为 <tt micros()> 计时之后也不需要按照板的特性调整传感数值了，不过都是 16 MHz 的 AVR 的话好像也没什么区别。

完成第一块 MCP4821 分线板的焊接，在面包板上搭起测试电路。其实自己不太懂焊接，只好边做边拿着万用表使劲“滴滴”。
!<img DAC_Circuit.jpg <= 面包板上的芯片，以及与之相连的 Arduino 开发板。>>
开始编写程序。查阅手册，Figure 1-1 是时序图（注：16 MHz 主频相当于每条指令 62.5 ns，16 kHz 采样率相当于每个采样 62.5 µs），Section 5 是 SPI 接口说明。
有一个驱动库可以直接使用，很方便，不用自己啃数据手册了。将 DAC 的输出直接连到 A0 端口，读出数值。程序如下。
!<filetable
  <file DAC_0515.ino 驱动 DAC 并检查其输出端电压>
>
上述程序实际上就是切换高低输出电压，再通过 <tt analogRead(A0)> 读回。串口打印 <tt 0 0>、<tt 1 812>，其中 812 是 DAC 输出 4.095 V 与参考电压 5 V 的比值缩放到 0~1023 范围内的结果，在误差允许范围内正确。

开始将放大器 LM386 加入整个电路，焊接在洞洞板上。暂时还未继续处理声音合成的问题。
!<img Audio_Circuit.jpg <= 焊接上各类元件形成电路的洞洞板> vertical>
目前的电路原理图如下。Arduino 左侧留出的引脚仅作示意，可连接十个传感电极；实际上传感电极引出的杜邦线均直接插入板上的基座。
!<img Schematic-Day-Neg-2.png <= 电路原理图，Arduino 依次连接 MCP4821、LM386、扬声器，中间带有几组滤波电路。> syncdarkmild>

由于没抽出时间改程序，所以还没有开始测试电路，只好寄希望于设计、焊接都不出现失误，到最后一次性接通。做软件时喜欢分成小段边写边测，这样的工作习惯碰到电路就只能抓瞎了，唉。
目前的方案是七个区域各自都需要一块控制器与电路板，所以焊接工作还需要重复很多遍。以及，用于研究声音合成的时间可能非常有限了。不知道来不来得及。

!<h1 Day -1 #Day-Minus-1>
今天下午有一节课，友人提出自己翘课当电焊工，让我正常去课堂，晚上再腾出时间专心解决程序上的问题。于是一下午过去，数块电路板的焊接工作全部完成。

傍晚终于开始编写输出声音的程序。先尝试方波。
!<<code= cpp
ISR(TIMER1_OVF_vect) {
  static int timerCount = 0;
  timerCount++;
  if (timerCount % 24 == 0)
    McpDac.analogWrite(((timerCount / 24) & 1) * 6);
}
>>
总算是发出了第一个声音。
!<filetable
  <file Sound.mp4 嘟——（不用调大音量）>
>
音量太大，向 DAC 中写入 6 时开始有声音，而 10 时已经达到相当充足的音量，这样一来有效位深只有 2 位，不可接受。因此拆去 LM386 第 1、8 引脚间的电容（上文原理图中 C4），将放大倍率从 200 改回 20。
采样率遇到瓶颈。32 kHz 采样率意味着每个采样只有 500 个指令周期，而且 AVR 没有硬件浮点单元，如果直接使用 <tt sinf> 计算很容易超时。将时钟换用 CTC 模式、降低到 4 kHz，并且换用 16 位定点计算，再加上预先计算查找表，时间才足够充裕。仍需注意 <tt int> 的长度只有 16 位，而涉及到 32 位乘法计算的整数是长整形——字面值末尾需要加 <tt L>。
!<filetable
  <file Oscillator_0516.ino 基础波形输出>
>
测试完成方波、正弦波、三角波、锯齿波等基础波形。然而有效位深还是非常有限：在 DAC 的分辨率为 1 mV（增益 = 1）时，输出 50 mV peak（35 mV RMS）的音量就已经相当大，这样有效位深仍然只有 6 位。不过，既然 1 kHz 正弦波的一个周期都只剩下 8 个采样，似乎位深也没有那么重要。
考虑换用缓冲区以降低每个采样的平均耗时，64 个采样的缓冲区相当于 4 kHz 采样率下的 16 ms 延迟，可以接受。但是要异步填充也很难实现，毕竟目前传感的做法还是忙循环，而一次传感采样的时间就可能达到数十甚至上百毫秒，要是在传感器的忙循环里面检查音频缓冲，是不是也太混乱了点。哎，最好的办法或许是在时钟中断里检查传感器接受端引脚，然后计算时间与传感器值、再扔进滤波和迟滞触发，但是这点时间可能也很难改过来了。音频合成输出加上电容传感忙循环是什么魔鬼组合啊啊啊。

不过无论如何，可以先开始试试放一些采样进去。先在电脑上用合成器搓出朴素的弦乐与鼓声音色，简单调了调，再写脚本把采样表打出来。
!<filetable
  <file gen_wavetable.lua 采样数值表>
>

接着给 Arduino 的程序加上采样器。
!<<code= cpp
template<int Length, const int16_t *Table> struct SampleSynth {
  int pos;
  SampleSynth() { pos = -1; }
  inline void start() { pos = 0; }
  inline int16_t sample() {
    if (pos < 0) return 0;
    int16_t result = pgm_read_word(&Table[pos]);  // 见下
    if (++pos == Length) pos = -1;
    return result;
  }
};
>>

然后贴上脚本生成的表，在时钟中断例程里控制循环播放与输出。
需要注意的是，由于数据量比较大，必须放入闪存（<tt .text>）而不能放在内存（<tt .data>）；仅使用 <tt const> 是不够的，还需要额外指明 <tt PROGMEM> 修饰符（即 <tt __attribute__((progmem))>），将其保留在闪存中，而不加载进 RAM；如此一来指针的值即为闪存地址而非 RAM 地址，需要使用 <tt pgm_read_*()> 函数方能读取到实际数据。上一段程序中的 <tt pgm_read_word()> 调用即是读取双字节宽度的采样。
!<<<code= cpp
const PROGMEM int16_t kickTable[] = { /* ... */ };
const PROGMEM int16_t stringsTable[] = { /* ... */ };
SampleSynth<sizeof kickTable / sizeof kickTable[0], kickTable> synKick;
SampleSynth<sizeof stringsTable / sizeof stringsTable[0], stringsTable> synStrings;

int16_t nextSample = 0;

ISR(TIMER1_COMPA_vect) {
  // 尽快输出上一个采样
  McpDac.fastWriteA(nextSample);

  // 合成下一个采样
  int16_t sample = 0;
  sample = sat_add(sample, synKick.sample());
  sample = sat_add(sample, synStrings.sample());
  uint16_t sample_i = (uint16_t)
    ((((int32_t)sample + (1L << 15)) * 120L + (1L << 15)) >> 16);
  nextSample = sample_i;

  // 每隔 2 秒从头播放一次
  static int timerCount = 0, pinStatus = 0;
  if ((timerCount = ((timerCount + 1) % 8000)) == 0) {
    digitalWrite(13, (pinStatus ^= 1));
    // synKick.start();
    synStrings.start();
  }
}
>>>

上传，确实能发出声音。然而采样率与位深的限制比想象中大得多，实际的声音与想象中有很大差异。虽然友人说实际上还可以，但这样真是很难接近设计中的“自然”声响，低频的声音则更是完全听不见。
!<note 注：也许主要的原因正如<link #Note-Filter-Value 前文>所述，是末尾的滤波电容不够大的缘故。>

{{contents.en=}}

{{toc=}}true
